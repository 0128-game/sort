<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Sorting Encyclopedia - Variable Speed Edition</title>
    <style>
        :root { --primary: #2563eb; --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --success: #2ecc71; }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { width: 95vw; max-width: 1200px; }
        .controls { background: var(--card); padding: 20px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; }
        .canvas-container { background: #000; border-radius: 8px; overflow: hidden; margin-bottom: 20px; border: 1px solid #334155; }
        canvas { width: 100%; height: 400px; display: block; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 15px; }
        .stat-card { background: var(--card); padding: 15px; border-radius: 10px; border-top: 4px solid var(--primary); }
        .label { font-size: 0.75rem; color: #94a3b8; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; }
        .value { font-size: 0.95rem; font-weight: 600; color: #fff; line-height: 1.4; }
        .timer-display { font-family: 'Courier New', monospace; color: #fbbf24; font-size: 1.4rem; }
        select, input, button { padding: 10px; border-radius: 6px; border: 1px solid #334155; background: #0f172a; color: #fff; font-size: 0.9rem; }
        button { background: var(--primary); color: white; border: none; font-weight: bold; cursor: pointer; }
        button:hover { background: #1d4ed8; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        .slider-group { display: flex; flex-direction: column; gap: 5px; }
    </style>
</head>
<body>

<div class="container">
    <h2>ã‚½ãƒ¼ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç©¶æ¥µå›³é‘‘ (é€Ÿåº¦èª¿æ•´ãƒ»å…¨ç¨®ç¶²ç¾…)</h2>

    <div class="controls">
        <div>
            <div class="label">ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </div>
            <select id="algoSelect" onchange="updateInfo()" style="width: 100%;">
                <optgroup label="ğŸš€ é«˜é€Ÿãƒ»å®Ÿç”¨">
                    <option value="quick">ã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆ</option>
                    <option value="merge">ãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆ</option>
                    <option value="heap">ãƒ’ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆ</option>
                    <option value="tim">ãƒ†ã‚£ãƒ ã‚½ãƒ¼ãƒˆ</option>
                    <option value="shell">ã‚·ã‚§ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                </optgroup>
                <optgroup label="ğŸ” åŸºæœ¬ãƒ»å­¦ç¿’ç”¨">
                    <option value="insertion">æŒ¿å…¥ã‚½ãƒ¼ãƒˆ</option>
                    <option value="selection">é¸æŠã‚½ãƒ¼ãƒˆ</option>
                    <option value="bubble">ãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                    <option value="cocktail">ã‚«ã‚¯ãƒ†ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                    <option value="gnome">ãƒãƒ¼ãƒ ã‚½ãƒ¼ãƒˆ</option>
                </optgroup>
                <optgroup label="ğŸ¤¡ ãƒã‚¿ãƒ»ç‰¹æ®Š">
                    <option value="abe">ã‚¢ãƒ™ã‚½ãƒ¼ãƒˆ</option>
                    <option value="stalin">ã‚¹ã‚¿ãƒ¼ãƒªãƒ³ã‚½ãƒ¼ãƒˆ</option>
                    <option value="sleep">ã‚¹ãƒªãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆ</option>
                    <option value="bogo">ãƒœã‚´ã‚½ãƒ¼ãƒˆ</option>
                    <option value="miracle">ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                </optgroup>
            </select>
        </div>
        <div class="slider-group">
            <div class="label">ãƒ‡ãƒ¼ã‚¿æ•°: <span id="countVal">300</span></div>
            <input type="range" id="dataCount" value="300" min="10" max="5000" step="10" oninput="document.getElementById('countVal').innerText=this.value">
        </div>
        <div class="slider-group">
            <div class="label">å¾…æ©Ÿæ™‚é–“ (é…ãã™ã‚‹): <span id="speedVal">10</span>ms</div>
            <input type="range" id="speedDelay" value="10" min="0" max="200" step="1" oninput="document.getElementById('speedVal').innerText=this.value">
        </div>
        <div style="display: flex; align-items: flex-end; gap: 10px;">
            <button onclick="resetAll()" style="background: #64748b;">ãƒªã‚»ãƒƒãƒˆ</button>
            <button onclick="startSort()" id="startBtn">é–‹å§‹</button>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="sortCanvas"></canvas>
    </div>

    <div class="stats-grid">
        <div class="stat-card"><div class="label">ä»•çµ„ã¿</div><div class="value" id="logicText">-</div></div>
        <div class="stat-card"><div class="label">è¨ˆç®—æ™‚é–“</div><div class="value" id="complexityText">-</div></div>
        <div class="stat-card"><div class="label">è¨ˆæ¸¬æ™‚é–“</div><div class="value timer-display" id="timeValue">0.000 ç§’</div></div>
    </div>
</div>

<script>
    let array = [];
    let isSorting = false;
    let timerInterval = null;
    let canvas, ctx;
    let highlightIdx = [];

    const info = {
        quick: { logic: "ãƒ”ãƒœãƒƒãƒˆã‚’åŸºæº–ã«åˆ†å‰²ã€‚å‹•ããŒé€Ÿã„ã®ã§ä½é€Ÿè¨­å®šãŒãŠã™ã™ã‚ã€‚", comp: "O(n log n)" },
        merge: { logic: "åˆ†å‰²ã—ã¦ã‹ã‚‰åˆä½“ã€‚å¤–éƒ¨ãƒ¡ãƒ¢ãƒªã«ä¸€æ™‚é€€é¿ã™ã‚‹æ§˜å­ã‚’å†ç¾ã€‚", comp: "O(n log n)" },
        heap: { logic: "é…åˆ—ã‚’æœ¨æ§‹é€ ã¨ã¿ãªã—ã€æœ€å¤§å€¤ã‹ã‚‰é †ã«æœ«å°¾ã¸é£›ã°ã™ã€‚", comp: "O(n log n)" },
        tim: { logic: "æŒ¿å…¥ã‚½ãƒ¼ãƒˆã¨ãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆã®ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã€‚å®Ÿç”¨çš„ã€‚", comp: "O(n log n)" },
        shell: { logic: "ä¸€å®šé–“éš”ã”ã¨ã«æŒ¿å…¥ã‚½ãƒ¼ãƒˆã‚’è¡Œã„ã€å¾ã€…ã«é–“éš”ã‚’è©°ã‚ã‚‹ã€‚", comp: "O(n log n)" },
        insertion: { logic: "æ•´åˆ—æ¸ˆã¿ã®åˆ—ã®é©åˆ‡ãªä½ç½®ã«è¦ç´ ã‚’å·®ã—è¾¼ã‚€ã€‚", comp: "O(nÂ²)" },
        selection: { logic: "æœ€å°å€¤ã‚’æ¢ç´¢ã—ã€æœªæ•´åˆ—ã®å…ˆé ­ã¨äº¤æ›ã™ã‚‹ã€‚", comp: "O(nÂ²)" },
        bubble: { logic: "éš£æ¥è¦ç´ ã‚’æ¯”è¼ƒãƒ»äº¤æ›ã€‚å¤§ãã„å€¤ãŒå³ã«æ²ˆã‚“ã§ã„ãã€‚", comp: "O(nÂ²)" },
        cocktail: { logic: "ãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆã‚’å·¦å³ä¸¡æ–¹å‘ã«å¾€å¾©ã•ã›ã‚‹ã€‚", comp: "O(nÂ²)" },
        gnome: { logic: "å¤§å°ãŒé€†ãªã‚‰äº¤æ›ã—ã¦ä¸€æ­©ä¸‹ãŒã‚‹ã€‚åº­å¸«ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã€‚", comp: "O(nÂ²)" },
        abe: { logic: "æœ€å¤§å€¤ã‚’ä¸‹å›ã‚‹å€¤ã‚’ã™ã¹ã¦æœ€å¤§å€¤ã§ä¸Šæ›¸ãã™ã‚‹ã€‚", comp: "O(n)" },
        stalin: { logic: "é †åºã‚’å®ˆã‚‰ãªã„è¦ç´ ã‚’0ï¼ˆæ’é™¤ï¼‰ã¨ã—ã¦æ‰±ã†ã€‚", comp: "O(n)" },
        sleep: { logic: "æ•°å€¤Ã—å¾…æ©Ÿæ™‚é–“åˆ†ã ã‘å¾…ã£ã¦ã‹ã‚‰é †ã«ç¢ºå®šã•ã›ã‚‹ã€‚", comp: "O(n+max)" },
        bogo: { logic: "æƒã†ã¾ã§å®Œå…¨ã«ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸¦ã³æ›¿ãˆã‚‹é‹ä»»ã›ã€‚", comp: "âˆ" },
        miracle: { logic: "ä½•ã‚‚ã›ãšã€ç‰©ç†çš„ãªå¥‡è·¡ã§ä¸¦ã³å¤‰ã‚ã‚‹ã®ã‚’å¾…ã¤ã€‚", comp: "âˆ" }
    };

    window.onload = () => {
        canvas = document.getElementById('sortCanvas');
        ctx = canvas.getContext('2d');
        resizeCanvas();
        updateInfo();
        resetAll();
    };

    function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const barWidth = canvas.width / array.length;
        for (let i = 0; i < array.length; i++) {
            let color = "#38bdf8";
            if (highlightIdx.includes(i)) color = "#ef4444";
            if (isSorting === 'finished') color = "#2ecc71";
            ctx.fillStyle = color;
            const barHeight = (array[i] / 100) * canvas.height;
            ctx.fillRect(i * barWidth, canvas.height - barHeight, Math.max(0.1, barWidth), barHeight);
        }
    }

    async function step(highlight = []) {
        if (!isSorting) throw "STOP";
        highlightIdx = highlight;
        draw();
        const delay = parseInt(document.getElementById('speedDelay').value);
        if (delay > 0) {
            await new Promise(r => setTimeout(r, delay));
        } else {
            // 0msã®æ™‚ã‚‚æç”»ã‚’åæ˜ ã•ã›ã‚‹ãŸã‚ã«ä¸€ç¬ã ã‘è§£æ”¾
            if (Math.random() < 0.1) await new Promise(r => requestAnimationFrame(r));
        }
    }

    function startTimer() {
        const startTime = performance.now();
        timerInterval = setInterval(() => {
            const diff = performance.now() - startTime;
            document.getElementById('timeValue').innerText = `${(diff / 1000).toFixed(3)} ç§’`;
        }, 30);
    }

    function resetAll() {
        isSorting = false;
        clearInterval(timerInterval);
        const count = parseInt(document.getElementById('dataCount').value);
        array = Array.from({length: count}, () => Math.random() * 90 + 5);
        highlightIdx = [];
        draw();
        document.getElementById('timeValue').innerText = "0.000 ç§’";
        document.getElementById('startBtn').disabled = false;
    }

    async function startSort() {
        isSorting = true;
        document.getElementById('startBtn').disabled = true;
        const a = document.getElementById('algoSelect').value;
        startTimer();

        try {
            if (a === 'quick') await quickSort(0, array.length - 1);
            else if (a === 'merge') await mergeSort(0, array.length - 1);
            else if (a === 'heap') await heapSort();
            else if (a === 'tim') await timSort();
            else if (a === 'shell') await shellSort();
            else if (a === 'insertion') await insertionSort();
            else if (a === 'selection') await selectionSort();
            else if (a === 'bubble') await bubbleSort();
            else if (a === 'cocktail') await cocktailSort();
            else if (a === 'gnome') await gnomeSort();
            else if (a === 'abe') await abeSort();
            else if (a === 'stalin') await stalinSort();
            else if (a === 'sleep') await sleepSort();
            else if (a === 'bogo') await bogoSort();
            else if (a === 'miracle') await miracleSort();

            clearInterval(timerInterval);
            isSorting = 'finished';
            draw();
        } catch (e) {
            clearInterval(timerInterval);
        } finally {
            document.getElementById('startBtn').disabled = false;
        }
    }

    // --- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£… ---
    async function quickSort(s, e) {
        if (s >= e) return;
        let p = array[e], i = s;
        for (let j = s; j < e; j++) {
            if (array[j] < p) { [array[i], array[j]] = [array[j], array[i]]; i++; await step([i, j]); }
        }
        [array[i], array[e]] = [array[e], array[i]];
        await step([i]);
        await quickSort(s, i - 1); await quickSort(i + 1, e);
    }

    async function mergeSort(s, e) {
        if (s >= e) return;
        let m = Math.floor((s + e) / 2);
        await mergeSort(s, m); await mergeSort(m + 1, e);
        let L = array.slice(s, m + 1), R = array.slice(m + 1, e + 1);
        let i = 0, j = 0, k = s;
        while (i < L.length && j < R.length) {
            array[k++] = (L[i] <= R[j]) ? L[i++] : R[j++]; await step([k]);
        }
        while (i < L.length) { array[k++] = L[i++]; await step([k]); }
        while (j < R.length) { array[k++] = R[j++]; await step([k]); }
    }

    async function heapSort() {
        const heapify = async (n, i) => {
            let largest = i, l = 2*i+1, r = 2*i+2;
            if (l < n && array[l] > array[largest]) largest = l;
            if (r < n && array[r] > array[largest]) largest = r;
            if (largest !== i) {
                [array[i], array[largest]] = [array[largest], array[i]];
                await step([i, largest]); await heapify(n, largest);
            }
        };
        for (let i = Math.floor(array.length/2)-1; i >= 0; i--) await heapify(array.length, i);
        for (let i = array.length-1; i > 0; i--) {
            [array[0], array[i]] = [array[i], array[0]];
            await step([i]); await heapify(i, 0);
        }
    }

    async function timSort() {
        let n = array.length, RUN = 32;
        for (let i = 0; i < n; i += RUN) {
            for (let j = i+1; j < Math.min(i+RUN, n); j++) {
                let temp = array[j], k = j-1;
                while (k >= i && array[k] > temp) { array[k+1] = array[k]; k--; await step([k]); }
                array[k+1] = temp;
            }
        }
        for (let size = RUN; size < n; size = 2*size) {
            for (let left = 0; left < n; left += 2*size) {
                let mid = left + size - 1, right = Math.min((left + 2*size - 1), (n-1));
                if (mid < right) {
                    let L = array.slice(left, mid+1), R = array.slice(mid+1, right+1);
                    let i = 0, j = 0, k = left;
                    while (i < L.length && j < R.length) { array[k++] = (L[i] <= R[j]) ? L[i++] : R[j++]; await step([k]); }
                    while (i < L.length) { array[k++] = L[i++]; await step([k]); }
                    while (j < R.length) { array[k++] = R[j++]; await step([k]); }
                }
            }
        }
    }

    async function bubbleSort() {
        for (let i = 0; i < array.length; i++) {
            for (let j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j+1]) { [array[j], array[j+1]] = [array[j+1], array[j]]; await step([j, j+1]); }
            }
        }
    }

    async function insertionSort() {
        for (let i = 1; i < array.length; i++) {
            let key = array[i], j = i - 1;
            while (j >= 0 && array[j] > key) { array[j+1] = array[j]; j--; await step([j, i]); }
            array[j+1] = key;
        }
    }

    async function selectionSort() {
        for (let i = 0; i < array.length; i++) {
            let m = i;
            for (let j = i + 1; j < array.length; j++) {
                if (array[j] < array[m]) { m = j; await step([i, j]); }
            }
            [array[i], array[m]] = [array[m], array[i]]; await step([i, m]);
        }
    }

    async function cocktailSort() {
        let l = 0, r = array.length - 1;
        while (l < r) {
            for (let i = l; i < r; i++) { if (array[i] > array[i+1]) [array[i], array[i+1]] = [array[i+1], array[i]]; await step([i]); }
            r--;
            for (let i = r; i > l; i--) { if (array[i] < array[i-1]) [array[i], array[i-1]] = [array[i-1], array[i]]; await step([i]); }
            l++;
        }
    }

    async function gnomeSort() {
        let i = 0;
        while (i < array.length) {
            if (i === 0 || array[i] >= array[i-1]) i++;
            else { [array[i], array[i-1]] = [array[i-1], array[i]]; i--; await step([i]); }
        }
    }

    async function shellSort() {
        for (let gap = Math.floor(array.length/2); gap > 0; gap = Math.floor(gap/2)) {
            for (let i = gap; i < array.length; i++) {
                let temp = array[i], j = i;
                while (j >= gap && array[j-gap] > temp) { array[j] = array[j-gap]; j -= gap; await step([j]); }
                array[j] = temp;
            }
        }
    }

    async function stalinSort() {
        let max = array[0];
        for (let i = 1; i < array.length; i++) {
            if (array[i] < max) array[i] = 0; else max = array[i];
            await step([i]);
        }
    }

    async function abeSort() {
        let max = array[0];
        for (let i = 1; i < array.length; i++) {
            if (array[i] < max) array[i] = max; else max = array[i];
            await step([i]);
        }
    }

    async function sleepSort() {
        let copy = [...array], res = [];
        const base = parseInt(document.getElementById('speedDelay').value) || 1;
        array.fill(0);
        copy.forEach(v => setTimeout(() => { if(!isSorting) return; res.push(v); array[res.length-1] = v; draw(); }, v * base * 2));
        while (res.length < copy.length) { await new Promise(r => setTimeout(r, 10)); if(!isSorting) return; }
    }

    async function bogoSort() {
        while (!array.every((v, i) => i === 0 || v >= array[i-1])) {
            for (let i = array.length-1; i > 0; i--) {
                const j = Math.floor(Math.random()*(i+1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            await step();
        }
    }

    async function miracleSort() {
        while (!array.every((v, i) => i === 0 || v >= array[i-1])) {
            await new Promise(r => setTimeout(r, 100));
            if (!isSorting) return;
        }
    }

    function updateInfo() {
        const a = document.getElementById('algoSelect').value;
        document.getElementById('logicText').innerText = info[a].logic;
        document.getElementById('complexityText').innerText = info[a].comp;
    }
</script>
</body>
</html>
