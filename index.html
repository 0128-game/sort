<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>The Complete Sorting Encyclopedia - 5000 Units</title>
    <style>
        :root { --primary: #2563eb; --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --success: #2ecc71; }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { width: 95vw; max-width: 1200px; }
        .controls { background: var(--card); padding: 20px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; }
        .canvas-container { background: #000; border-radius: 8px; overflow: hidden; margin-bottom: 20px; border: 1px solid #334155; position: relative; }
        canvas { width: 100%; height: 400px; display: block; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 15px; }
        .stat-card { background: var(--card); padding: 15px; border-radius: 10px; border-top: 4px solid var(--primary); }
        .label { font-size: 0.75rem; color: #94a3b8; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; }
        .value { font-size: 0.95rem; font-weight: 600; color: #fff; line-height: 1.4; }
        .timer-display { font-family: 'Courier New', monospace; color: #fbbf24; font-size: 1.4rem; }
        select, input, button { padding: 10px; border-radius: 6px; border: 1px solid #334155; background: #0f172a; color: #fff; font-size: 0.9rem; }
        button { background: var(--primary); color: white; border: none; font-weight: bold; cursor: pointer; }
        button:hover { background: #1d4ed8; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
    </style>
</head>
<body>

<div class="container">
    <h2>ã‚½ãƒ¼ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç©¶æ¥µå›³é‘‘ (å…¨ç¨®ç¶²ç¾…ãƒ»5,000ä»¶å¯¾å¿œ)</h2>

    <div class="controls">
        <div>
            <div class="label">ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </div>
            <select id="algoSelect" onchange="updateInfo()" style="width: 100%;">
                <optgroup label="ğŸš€ å¤§è¦æ¨¡å‘ã (é«˜é€Ÿ)">
                    <option value="quick">ã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆ</option>
                    <option value="merge">ãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆ</option>
                    <option value="heap">ãƒ’ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆ</option>
                    <option value="tim">ãƒ†ã‚£ãƒ ã‚½ãƒ¼ãƒˆ</option>
                    <option value="shell">ã‚·ã‚§ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                </optgroup>
                <optgroup label="ğŸ” ä¸­ãƒ»å°è¦æ¨¡å‘ã">
                    <option value="insertion">æŒ¿å…¥ã‚½ãƒ¼ãƒˆ</option>
                    <option value="selection">é¸æŠã‚½ãƒ¼ãƒˆ</option>
                    <option value="bubble">ãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                    <option value="cocktail">ã‚«ã‚¯ãƒ†ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                    <option value="gnome">ãƒãƒ¼ãƒ ã‚½ãƒ¼ãƒˆ</option>
                </optgroup>
                <optgroup label="ğŸ¤¡ ãƒã‚¿ã‚»ã‚¯ã‚·ãƒ§ãƒ³">
                    <option value="abe">ã‚¢ãƒ™ã‚½ãƒ¼ãƒˆ (ä¸Šæ–¹ä¿®æ­£)</option>
                    <option value="stalin">ã‚¹ã‚¿ãƒ¼ãƒªãƒ³ã‚½ãƒ¼ãƒˆ (å›ºå®šç²›æ¸…)</option>
                    <option value="sleep">ã‚¹ãƒªãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆ (æ™‚é–“ä¾å­˜)</option>
                    <option value="bogo">ãƒœã‚´ã‚½ãƒ¼ãƒˆ (ç¥é ¼ã¿)</option>
                    <option value="miracle">ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒˆ (å¥‡è·¡)</option>
                </optgroup>
            </select>
        </div>
        <div>
            <div class="label">ãƒ‡ãƒ¼ã‚¿æ•° (ç¾åœ¨: <span id="countVal">1000</span>)</div>
            <input type="range" id="dataCount" value="1000" min="10" max="5000" step="10" oninput="document.getElementById('countVal').innerText=this.value" style="width: 90%;">
        </div>
        <div style="display: flex; align-items: flex-end; gap: 10px;">
            <button onclick="resetAll()" style="background: #64748b;">ãƒªã‚»ãƒƒãƒˆ</button>
            <button onclick="startSort()" id="startBtn">è¨ˆæ¸¬é–‹å§‹</button>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="sortCanvas"></canvas>
    </div>

    <div class="stats-grid">
        <div class="stat-card"><div class="label">ä»•çµ„ã¿</div><div class="value" id="logicText">-</div></div>
        <div class="stat-card"><div class="label">è¨ˆç®—æ™‚é–“</div><div class="value" id="complexityText">-</div></div>
        <div class="stat-card"><div class="label">å®Ÿè¡Œè¨ˆæ¸¬æ™‚é–“</div><div class="value timer-display" id="timeValue">0.000 ç§’ (0.00 ms)</div></div>
    </div>
</div>

<script>
    let array = [];
    let isSorting = false;
    let timerInterval = null;
    let canvas, ctx;
    let highlightIdx = [];

    const info = {
        quick: { logic: "ãƒ”ãƒœãƒƒãƒˆã‚’åŸºæº–ã«å†å¸°çš„ã«åˆ†å‰²ã€‚å¹³å‡æœ€é€Ÿã‚¯ãƒ©ã‚¹ã€‚", comp: "O(n log n) / O(nÂ²)" },
        merge: { logic: "åˆ†å‰²ã—ã¦ã‹ã‚‰æ•´åˆ—ã—ã¤ã¤åˆä½“ã€‚å®‰å®šæ€§ãŒé«˜ã„ã€‚", comp: "O(n log n) / O(n log n)" },
        heap: { logic: "æœ¨æ§‹é€ ã‚’ä½œã‚Šã€æœ€å¤§å€¤ã‹ã‚‰é †ã«å–ã‚Šå‡ºã™ã€‚", comp: "O(n log n) / O(n log n)" },
        tim: { logic: "æŒ¿å…¥ã¨ãƒãƒ¼ã‚¸ã®ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã€‚å®Ÿç”¨æœ€å¼·å€™è£œã€‚", comp: "O(n) / O(n log n)" },
        shell: { logic: "é–“éš”ã‚’ã‚ã‘ãŸæŒ¿å…¥ã‚½ãƒ¼ãƒˆã®æ”¹è‰¯ç‰ˆã€‚", comp: "O(n log n) / O(nÂ²)" },
        insertion: { logic: "æ•´åˆ—æ¸ˆã¿ç¯„å›²ã«é©åˆ‡ãªä½ç½®ã¸æŒ¿å…¥ã™ã‚‹ã€‚", comp: "O(n) / O(nÂ²)" },
        selection: { logic: "æœ€å°å€¤ã‚’æ¢ã—ã¦å…ˆé ­ã¨å…¥ã‚Œæ›¿ãˆã‚‹ã€‚", comp: "O(nÂ²) / O(nÂ²)" },
        bubble: { logic: "éš£åŒå£«ã‚’æ¯”è¼ƒã—ã¦å…¥ã‚Œæ›¿ãˆã‚‹åŸºæœ¬å½¢ã€‚", comp: "O(n) / O(nÂ²)" },
        cocktail: { logic: "ãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆã‚’å·¦å³å¾€å¾©ã•ã›ãŸæ”¹è‰¯å‹ã€‚", comp: "O(n) / O(nÂ²)" },
        gnome: { logic: "ä¸€æ­©é€²ã‚“ã§ã€é€†è»¢ãŒã‚ã‚Œã°æˆ»ã£ã¦ç›´ã™åº­å¸«ã®å‹•ãã€‚", comp: "O(n) / O(nÂ²)" },
        abe: { logic: "æœ€å¤§å€¤ã‚’ä¸‹å›ã‚‹è¦ç´ ã‚’æœ€å¤§å€¤ã¸å¼·åˆ¶æ›¸ãæ›ãˆã€‚", comp: "O(n) / O(n)" },
        stalin: { logic: "é †åºã‚’ä¹±ã™è¦ç´ ã‚’ãã®å ´ã§0ï¼ˆæ¶ˆå»ï¼‰ã«ã™ã‚‹ã€‚", comp: "O(n) / O(n)" },
        sleep: { logic: "æ•°å€¤ã«å¿œã˜ãŸæ™‚é–“å¾…æ©Ÿã—ã¦ç¢ºå®šã•ã›ã‚‹ã€‚", comp: "O(n + max)" },
        bogo: { logic: "æƒã†ã¾ã§å®Œå…¨ã«ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸¦ã³æ›¿ãˆã‚‹ã€‚", comp: "O(n) / âˆ" },
        miracle: { logic: "ä½•ã‚‚ã›ãšã€å¥‡è·¡çš„ã«æƒã†ã®ã‚’å¾…ã¤ã€‚", comp: "O(n) / âˆ" }
    };

    window.onload = () => {
        canvas = document.getElementById('sortCanvas');
        ctx = canvas.getContext('2d');
        resizeCanvas();
        updateInfo();
        resetAll();
    };

    function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const barWidth = canvas.width / array.length;
        for (let i = 0; i < array.length; i++) {
            let color = "#38bdf8";
            if (highlightIdx.includes(i)) color = "#ef4444";
            if (isSorting === 'finished') color = "#2ecc71";
            ctx.fillStyle = color;
            const barHeight = (array[i] / 100) * canvas.height;
            ctx.fillRect(i * barWidth, canvas.height - barHeight, Math.max(1, barWidth), barHeight);
        }
    }

    function startTimer() {
        const startTime = performance.now();
        timerInterval = setInterval(() => {
            const diff = performance.now() - startTime;
            document.getElementById('timeValue').innerText = `${(diff / 1000).toFixed(3)} ç§’ (${diff.toFixed(2)} ms)`;
        }, 16);
    }

    function resetAll() {
        isSorting = false;
        clearInterval(timerInterval);
        const count = parseInt(document.getElementById('dataCount').value);
        array = Array.from({length: count}, () => Math.random() * 90 + 5);
        highlightIdx = [];
        draw();
        document.getElementById('timeValue').innerText = "0.000 ç§’ (0.00 ms)";
        document.getElementById('startBtn').disabled = false;
    }

    const nextFrame = () => new Promise(r => requestAnimationFrame(r));
    async function checkStop(mod = 50) {
        if (!isSorting) throw "STOP";
        if (Math.random() < (1/mod)) { draw(); await nextFrame(); }
    }

    async function startSort() {
        isSorting = true;
        document.getElementById('startBtn').disabled = true;
        const a = document.getElementById('algoSelect').value;
        startTimer();

        try {
            if (a === 'quick') await quickSort(0, array.length - 1);
            else if (a === 'merge') await mergeSort(0, array.length - 1);
            else if (a === 'heap') await heapSort();
            else if (a === 'tim') await timSort();
            else if (a === 'shell') await shellSort();
            else if (a === 'insertion') await insertionSort();
            else if (a === 'selection') await selectionSort();
            else if (a === 'bubble') await bubbleSort();
            else if (a === 'cocktail') await cocktailSort();
            else if (a === 'gnome') await gnomeSort();
            else if (a === 'abe') await abeSort();
            else if (a === 'stalin') await stalinSort();
            else if (a === 'sleep') await sleepSort();
            else if (a === 'bogo') await bogoSort();
            else if (a === 'miracle') await miracleSort();

            clearInterval(timerInterval);
            isSorting = 'finished';
            await finishEffect();
        } catch (e) {
            clearInterval(timerInterval);
        } finally {
            document.getElementById('startBtn').disabled = false;
        }
    }

    async function finishEffect() {
        const step = Math.ceil(array.length / 50);
        for (let i = 0; i < array.length; i += step) {
            if (!isSorting) return;
            draw();
            await nextFrame();
        }
        draw();
    }

    // --- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£… ---
    async function quickSort(s, e) {
        if (s >= e) return;
        let p = array[e], i = s;
        for (let j = s; j < e; j++) {
            await checkStop(100);
            if (array[j] < p) { [array[i], array[j]] = [array[j], array[i]]; i++; }
        }
        [array[i], array[e]] = [array[e], array[i]];
        highlightIdx = [i];
        await quickSort(s, i - 1); await quickSort(i + 1, e);
    }

    async function mergeSort(s, e) {
        if (s >= e) return;
        let m = Math.floor((s + e) / 2);
        await mergeSort(s, m); await mergeSort(m + 1, e);
        let L = array.slice(s, m + 1), R = array.slice(m + 1, e + 1);
        let i = 0, j = 0, k = s;
        while (i < L.length && j < R.length) {
            await checkStop(100);
            array[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
            highlightIdx = [k];
        }
        while (i < L.length) { array[k++] = L[i++]; await checkStop(500); }
        while (j < R.length) { array[k++] = R[j++]; await checkStop(500); }
    }

    async function heapSort() {
        const heapify = async (n, i) => {
            let largest = i, l = 2*i+1, r = 2*i+2;
            if (l < n && array[l] > array[largest]) largest = l;
            if (r < n && array[r] > array[largest]) largest = r;
            if (largest !== i) {
                [array[i], array[largest]] = [array[largest], array[i]];
                await checkStop(100);
                await heapify(n, largest);
            }
        };
        for (let i = Math.floor(array.length/2)-1; i >= 0; i--) await heapify(array.length, i);
        for (let i = array.length-1; i > 0; i--) {
            [array[0], array[i]] = [array[i], array[0]];
            highlightIdx = [i]; await heapify(i, 0);
        }
    }

    async function timSort() {
        let n = array.length, RUN = 32;
        for (let i = 0; i < n; i += RUN) {
            for (let j = i+1; j < Math.min(i+RUN, n); j++) {
                let temp = array[j], k = j-1;
                while (k >= i && array[k] > temp) { array[k+1] = array[k]; k--; await checkStop(500); }
                array[k+1] = temp;
            }
        }
        for (let size = RUN; size < n; size = 2*size) {
            for (let left = 0; left < n; left += 2*size) {
                let mid = left + size - 1, right = Math.min((left + 2*size - 1), (n-1));
                if (mid < right) {
                    let L = array.slice(left, mid+1), R = array.slice(mid+1, right+1);
                    let i = 0, j = 0, k = left;
                    while (i < L.length && j < R.length) {
                        await checkStop(200);
                        array[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
                    }
                    while (i < L.length) array[k++] = L[i++];
                    while (j < R.length) array[k++] = R[j++];
                }
            }
        }
    }

    async function bubbleSort() {
        for (let i = 0; i < array.length; i++) {
            for (let j = 0; j < array.length - i - 1; j++) {
                await checkStop(1000);
                if (array[j] > array[j+1]) [array[j], array[j+1]] = [array[j+1], array[j]];
            }
            highlightIdx = [array.length-i];
        }
    }

    async function insertionSort() {
        for (let i = 1; i < array.length; i++) {
            let key = array[i], j = i - 1;
            while (j >= 0 && array[j] > key) {
                await checkStop(1000);
                array[j+1] = array[j]; j--;
            }
            array[j+1] = key;
            highlightIdx = [i];
        }
    }

    async function cocktailSort() {
        let l = 0, r = array.length - 1;
        while (l < r) {
            for (let i = l; i < r; i++) { await checkStop(1000); if (array[i] > array[i+1]) [array[i], array[i+1]] = [array[i+1], array[i]]; }
            r--;
            for (let i = r; i > l; i--) { await checkStop(1000); if (array[i] < array[i-1]) [array[i], array[i-1]] = [array[i-1], array[i]]; }
            l++;
        }
    }

    async function gnomeSort() {
        let i = 0;
        while (i < array.length) {
            await checkStop(1000);
            if (i === 0 || array[i] >= array[i-1]) i++;
            else { [array[i], array[i-1]] = [array[i-1], array[i]]; i--; highlightIdx = [i]; }
        }
    }

    async function shellSort() {
        for (let gap = Math.floor(array.length/2); gap > 0; gap = Math.floor(gap/2)) {
            for (let i = gap; i < array.length; i++) {
                let temp = array[i], j = i;
                while (j >= gap && array[j-gap] > temp) {
                    await checkStop(500);
                    array[j] = array[j-gap]; j -= gap;
                }
                array[j] = temp;
            }
        }
    }

    async function stalinSort() {
        let max = array[0];
        for (let i = 1; i < array.length; i++) {
            await checkStop(100);
            if (array[i] < max) array[i] = 0; else max = array[i];
            highlightIdx = [i];
        }
    }

    async function abeSort() {
        let max = array[0];
        for (let i = 1; i < array.length; i++) {
            await checkStop(100);
            if (array[i] < max) array[i] = max; else max = array[i];
            highlightIdx = [i];
        }
    }

    async function sleepSort() {
        let copy = [...array], res = [];
        array.fill(0);
        const maxVal = Math.max(...copy);
        copy.forEach(v => setTimeout(() => { if(isSorting==='finished'||!isSorting) return; res.push(v); array[res.length-1] = v; highlightIdx=[res.length-1]; draw(); }, v * 20));
        while (res.length < copy.length) { await checkStop(10); if(!isSorting) return; }
    }

    async function bogoSort() {
        while (!array.every((v, i) => i === 0 || v >= array[i-1])) {
            await checkStop(10);
            for (let i = array.length-1; i > 0; i--) {
                const j = Math.floor(Math.random()*(i+1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
    }

    async function miracleSort() {
        while (!array.every((v, i) => i === 0 || v >= array[i-1])) {
            await checkStop(10);
        }
    }

    async function selectionSort() {
        for (let i = 0; i < array.length; i++) {
            let m = i;
            for (let j = i + 1; j < array.length; j++) {
                await checkStop(2000);
                if (array[j] < array[m]) m = j;
            }
            [array[i], array[m]] = [array[m], array[i]];
            highlightIdx = [i];
        }
    }

    function updateInfo() {
        const a = document.getElementById('algoSelect').value;
        document.getElementById('logicText').innerText = info[a].logic;
        document.getElementById('complexityText').innerText = info[a].comp;
    }
</script>
</body>
</html>
