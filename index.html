<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Sorting Encyclopedia - Slow Motion Edition</title>
    <style>
        :root { --primary: #2563eb; --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --success: #2ecc71; }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { width: 95vw; max-width: 1200px; }
        .controls { background: var(--card); padding: 20px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; }
        .canvas-container { background: #000; border-radius: 8px; overflow: hidden; margin-bottom: 20px; border: 1px solid #334155; }
        canvas { width: 100%; height: 400px; display: block; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 15px; }
        .stat-card { background: var(--card); padding: 15px; border-radius: 10px; border-top: 4px solid var(--primary); }
        .label { font-size: 0.75rem; color: #94a3b8; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; }
        .value { font-size: 0.95rem; font-weight: 600; color: #fff; line-height: 1.4; }
        .timer-display { font-family: 'Courier New', monospace; color: #fbbf24; font-size: 1.4rem; }
        select, input, button { padding: 10px; border-radius: 6px; border: 1px solid #334155; background: #0f172a; color: #fff; font-size: 0.9rem; }
        button { background: var(--primary); color: white; border: none; font-weight: bold; cursor: pointer; }
        button:hover { background: #1d4ed8; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
    </style>
</head>
<body>

<div class="container">
    <h2>ã‚½ãƒ¼ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç©¶æ¥µå›³é‘‘ (ä½é€Ÿãƒ»å…¨ç¨®ç¶²ç¾…)</h2>

    <div class="controls">
        <div>
            <div class="label">ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </div>
            <select id="algoSelect" onchange="updateInfo()" style="width: 100%;">
                <optgroup label="ğŸš€ é«˜é€Ÿãƒ»å®Ÿç”¨">
                    <option value="quick">ã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆ</option>
                    <option value="merge">ãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆ</option>
                    <option value="heap">ãƒ’ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆ</option>
                    <option value="tim">ãƒ†ã‚£ãƒ ã‚½ãƒ¼ãƒˆ</option>
                    <option value="shell">ã‚·ã‚§ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                </optgroup>
                <optgroup label="ğŸ” åŸºæœ¬ãƒ»å­¦ç¿’ç”¨">
                    <option value="insertion">æŒ¿å…¥ã‚½ãƒ¼ãƒˆ</option>
                    <option value="selection">é¸æŠã‚½ãƒ¼ãƒˆ</option>
                    <option value="bubble">ãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                    <option value="cocktail">ã‚«ã‚¯ãƒ†ãƒ«ã‚½ãƒ¼ãƒˆ</option>
                    <option value="gnome">ãƒãƒ¼ãƒ ã‚½ãƒ¼ãƒˆ</option>
                </optgroup>
                <optgroup label="ğŸ¤¡ ãƒã‚¿ãƒ»ç‰¹æ®Š">
                    <option value="abe">ã‚¢ãƒ™ã‚½ãƒ¼ãƒˆ (ä¸Šæ–¹ä¿®æ­£)</option>
                    <option value="stalin">ã‚¹ã‚¿ãƒ¼ãƒªãƒ³ã‚½ãƒ¼ãƒˆ (å›ºå®šç²›æ¸…)</option>
                    <option value="sleep">ã‚¹ãƒªãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆ (æ™‚é–“ä¾å­˜)</option>
                    <option value="bogo">ãƒœã‚´ã‚½ãƒ¼ãƒˆ (ç¥é ¼ã¿)</option>
                    <option value="miracle">ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒˆ (å¥‡è·¡å¾…ã¡)</option>
                </optgroup>
            </select>
        </div>
        <div>
            <div class="label">ãƒ‡ãƒ¼ã‚¿æ•° (ç¾åœ¨: <span id="countVal">300</span>)</div>
            <input type="range" id="dataCount" value="300" min="10" max="5000" step="10" oninput="document.getElementById('countVal').innerText=this.value" style="width: 90%;">
        </div>
        <div style="display: flex; align-items: flex-end; gap: 10px;">
            <button onclick="resetAll()" style="background: #64748b;">ãƒªã‚»ãƒƒãƒˆ</button>
            <button onclick="startSort()" id="startBtn">è¨ˆæ¸¬é–‹å§‹</button>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="sortCanvas"></canvas>
    </div>

    <div class="stats-grid">
        <div class="stat-card"><div class="label">ä»•çµ„ã¿</div><div class="value" id="logicText">-</div></div>
        <div class="stat-card"><div class="label">è¨ˆç®—æ™‚é–“</div><div class="value" id="complexityText">-</div></div>
        <div class="stat-card"><div class="label">å®Ÿè¡Œè¨ˆæ¸¬æ™‚é–“</div><div class="value timer-display" id="timeValue">0.000 ç§’ (0.00 ms)</div></div>
    </div>
</div>

<script>
    let array = [];
    let isSorting = false;
    let timerInterval = null;
    let canvas, ctx;
    let highlightIdx = [];

    const info = {
        quick: { logic: "åŸºæº–(ãƒ”ãƒœãƒƒãƒˆ)ã‚ˆã‚Šå¤§ãã„ã‹å°ã•ã„ã‹ã§åˆ†ã‘ã‚‹ã€‚å‹•ããŒãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã€‚", comp: "O(n log n) / O(nÂ²)" },
        merge: { logic: "åŠåˆ†ã«å‰²ã‚Šç¶šã‘ã€æ•´åˆ—ã—ãªãŒã‚‰æˆ»ã™ã€‚å¤–éƒ¨ãƒ¡ãƒ¢ãƒªã‚’ä½¿ã†æ§˜å­ã‚’å†ç¾ã€‚", comp: "O(n log n) / O(n log n)" },
        heap: { logic: "é…åˆ—ã‚’æœ¨æ§‹é€ ã«ã—ã€æœ€å¤§å€¤ã‚’å¾Œã‚ã¸é£›ã°ã—ã¦ã„ãã€‚", comp: "O(n log n) / O(n log n)" },
        tim: { logic: "æŒ¿å…¥ã¨ãƒãƒ¼ã‚¸ã®ã„ã„ã¨ã“å–ã‚Šã€‚å®Ÿç”¨çš„ãªåˆ†å‰²å‹•ä½œãŒè¦‹æ‰€ã€‚", comp: "O(n) / O(n log n)" },
        shell: { logic: "é£›ã³é£›ã³ã®ç¯„å›²ã§ã‚½ãƒ¼ãƒˆã—ã€å¾ã€…ã«é–“éš”ã‚’è©°ã‚ã‚‹ã€‚", comp: "O(n log n) / O(nÂ²)" },
        insertion: { logic: "ä¸€æšãšã¤æ­£ã—ã„ä½ç½®ã¸å·®ã—è¾¼ã‚“ã§ã„ãã€‚ãƒˆãƒ©ãƒ³ãƒ—ã®æ•´ç†ã«è¿‘ã„ã€‚", comp: "O(n) / O(nÂ²)" },
        selection: { logic: "æœªæ•´åˆ—ã‹ã‚‰æœ€å°å€¤ã‚’æ¢ã—ã€å…ˆé ­ã¨äº¤æ›ã™ã‚‹ã€‚", comp: "O(nÂ²) / O(nÂ²)" },
        bubble: { logic: "éš£åŒå£«ã‚’å…¥ã‚Œæ›¿ãˆã€é‡ã„ã‚‚ã®ãŒä¸‹ã«æ²ˆã‚“ã§ã„ãã€‚", comp: "O(n) / O(nÂ²)" },
        cocktail: { logic: "å·¦å³ã«å¾€å¾©ã—ãªãŒã‚‰æ³¡ç«‹ã¦ã‚‹ã‚ˆã†ã«æ•´åˆ—ã™ã‚‹ã€‚", comp: "O(n) / O(nÂ²)" },
        gnome: { logic: "å…¥ã‚Œæ›¿ãˆãŸã‚‰ä¸€æ­©æˆ»ã‚‹ã€‚åº­å¸«(ãƒãƒ¼ãƒ )ã®ç²˜ã‚Šå¼·ã„å‹•ãã€‚", comp: "O(n) / O(nÂ²)" },
        abe: { logic: "æœ€å¤§å€¤ã‚ˆã‚Šä½ã„ã‚‚ã®ã¯å…¨ã¦æœ€å¤§å€¤ã«ä¸Šæ›¸ãã™ã‚‹ã€‚", comp: "O(n) / O(n)" },
        stalin: { logic: "é †åºã‚’ä¹±ã™è€…ã¯å³åº§ã«0ã¨ã—ã¦æ’é™¤ã™ã‚‹ã€‚", comp: "O(n) / O(n)" },
        sleep: { logic: "æ•°å€¤ã«æ¯”ä¾‹ã—ãŸæ™‚é–“ã‚’å¾…ã£ã¦ã‹ã‚‰ç¢ºå®šã•ã›ã‚‹ã€‚", comp: "O(n + max)" },
        bogo: { logic: "å®Œå…¨ã«é‹ã€‚æƒã†ã¾ã§ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚’ç¹°ã‚Šè¿”ã™ã€‚", comp: "O(n) / âˆ" },
        miracle: { logic: "ä½•ã‚‚ã—ãªã„ã€‚å®‡å®™ã®å¥‡è·¡ã§æƒã†ã¾ã§ã‚¿ã‚¤ãƒãƒ¼ãŒå›ã‚‹ã€‚", comp: "O(n) / âˆ" }
    };

    window.onload = () => {
        canvas = document.getElementById('sortCanvas');
        ctx = canvas.getContext('2d');
        resizeCanvas();
        updateInfo();
        resetAll();
    };

    function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const barWidth = canvas.width / array.length;
        for (let i = 0; i < array.length; i++) {
            let color = "#38bdf8";
            if (highlightIdx.includes(i)) color = "#ef4444";
            if (isSorting === 'finished') color = "#2ecc71";
            ctx.fillStyle = color;
            const barHeight = (array[i] / 100) * canvas.height;
            ctx.fillRect(i * barWidth, canvas.height - barHeight, Math.max(0.5, barWidth), barHeight);
        }
    }

    const nextFrame = () => new Promise(r => requestAnimationFrame(r));
    
    // é€Ÿåº¦èª¿æ•´ç”¨ã®å…±é€šé–¢æ•°ï¼ˆã“ã“ã‚’é…ãã—ã¾ã—ãŸï¼‰
    async function step(highlight = [], mod = 1) {
        if (!isSorting) throw "STOP";
        highlightIdx = highlight;
        draw();
        // 5000ä»¶ã®æ™‚ã¯å°‘ã—é€Ÿãã€å°‘ãªã„æ™‚ã¯ã‚ˆã‚Šé…ããªã‚‹ã‚ˆã†èª¿æ•´
        const baseDelay = array.length > 500 ? 1 : 20; 
        await new Promise(r => setTimeout(r, baseDelay * mod));
    }

    function startTimer() {
        const startTime = performance.now();
        timerInterval = setInterval(() => {
            const diff = performance.now() - startTime;
            document.getElementById('timeValue').innerText = `${(diff / 1000).toFixed(3)} ç§’ (${diff.toFixed(2)} ms)`;
        }, 16);
    }

    function resetAll() {
        isSorting = false;
        clearInterval(timerInterval);
        const count = parseInt(document.getElementById('dataCount').value);
        array = Array.from({length: count}, () => Math.random() * 90 + 5);
        highlightIdx = [];
        draw();
        document.getElementById('timeValue').innerText = "0.000 ç§’ (0.00 ms)";
        document.getElementById('startBtn').disabled = false;
    }

    async function startSort() {
        isSorting = true;
        document.getElementById('startBtn').disabled = true;
        const a = document.getElementById('algoSelect').value;
        startTimer();

        try {
            if (a === 'quick') await quickSort(0, array.length - 1);
            else if (a === 'merge') await mergeSort(0, array.length - 1);
            else if (a === 'heap') await heapSort();
            else if (a === 'tim') await timSort();
            else if (a === 'shell') await shellSort();
            else if (a === 'insertion') await insertionSort();
            else if (a === 'selection') await selectionSort();
            else if (a === 'bubble') await bubbleSort();
            else if (a === 'cocktail') await cocktailSort();
            else if (a === 'gnome') await gnomeSort();
            else if (a === 'abe') await abeSort();
            else if (a === 'stalin') await stalinSort();
            else if (a === 'sleep') await sleepSort();
            else if (a === 'bogo') await bogoSort();
            else if (a === 'miracle') await miracleSort();

            clearInterval(timerInterval);
            isSorting = 'finished';
            await finishEffect();
        } catch (e) {
            clearInterval(timerInterval);
        } finally {
            document.getElementById('startBtn').disabled = false;
        }
    }

    async function finishEffect() {
        const stepSize = Math.ceil(array.length / 60);
        for (let i = 0; i < array.length; i += stepSize) {
            if (!isSorting) return;
            draw();
            await nextFrame();
        }
        draw();
    }

    // --- å„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£… (ã‚¦ã‚§ã‚¤ãƒˆã‚’å¼·åŒ–) ---
    async function quickSort(s, e) {
        if (s >= e) return;
        let p = array[e], i = s;
        for (let j = s; j < e; j++) {
            if (array[j] < p) { 
                [array[i], array[j]] = [array[j], array[i]]; i++; 
                await step([i, j], 0.5); 
            }
        }
        [array[i], array[e]] = [array[e], array[i]];
        await step([i]);
        await quickSort(s, i - 1); await quickSort(i + 1, e);
    }

    async function mergeSort(s, e) {
        if (s >= e) return;
        let m = Math.floor((s + e) / 2);
        await mergeSort(s, m); await mergeSort(m + 1, e);
        let L = array.slice(s, m + 1), R = array.slice(m + 1, e + 1);
        let i = 0, j = 0, k = s;
        while (i < L.length && j < R.length) {
            array[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
            await step([k]);
        }
        while (i < L.length) { array[k++] = L[i++]; await step([k]); }
        while (j < R.length) { array[k++] = R[j++]; await step([k]); }
    }

    async function heapSort() {
        const heapify = async (n, i) => {
            let largest = i, l = 2*i+1, r = 2*i+2;
            if (l < n && array[l] > array[largest]) largest = l;
            if (r < n && array[r] > array[largest]) largest = r;
            if (largest !== i) {
                [array[i], array[largest]] = [array[largest], array[i]];
                await step([i, largest]);
                await heapify(n, largest);
            }
        };
        for (let i = Math.floor(array.length/2)-1; i >= 0; i--) await heapify(array.length, i);
        for (let i = array.length-1; i > 0; i--) {
            [array[0], array[i]] = [array[i], array[0]];
            await step([i]); await heapify(i, 0);
        }
    }

    async function timSort() {
        let n = array.length, RUN = 32;
        for (let i = 0; i < n; i += RUN) {
            for (let j = i+1; j < Math.min(i+RUN, n); j++) {
                let temp = array[j], k = j-1;
                while (k >= i && array[k] > temp) { array[k+1] = array[k]; k--; await step([k, j], 0.1); }
                array[k+1] = temp;
            }
        }
        for (let size = RUN; size < n; size = 2*size) {
            for (let left = 0; left < n; left += 2*size) {
                let mid = left + size - 1, right = Math.min((left + 2*size - 1), (n-1));
                if (mid < right) {
                    let L = array.slice(left, mid+1), R = array.slice(mid+1, right+1);
                    let i = 0, j = 0, k = left;
                    while (i < L.length && j < R.length) { array[k++] = (L[i] <= R[j]) ? L[i++] : R[j++]; await step([k]); }
                    while (i < L.length) { array[k++] = L[i++]; await step([k]); }
                    while (j < R.length) { array[k++] = R[j++]; await step([k]); }
                }
            }
        }
    }

    async function bubbleSort() {
        for (let i = 0; i < array.length; i++) {
            for (let j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j+1]) [array[j], array[j+1]] = [array[j+1], array[j]];
                if (j % Math.ceil(array.length/100) === 0) await step([j, j+1], 0.1);
            }
        }
    }

    async function insertionSort() {
        for (let i = 1; i < array.length; i++) {
            let key = array[i], j = i - 1;
            while (j >= 0 && array[j] > key) {
                array[j+1] = array[j]; j--;
                if (j % Math.ceil(array.length/100) === 0) await step([j, i], 0.1);
            }
            array[j+1] = key;
        }
    }

    async function selectionSort() {
        for (let i = 0; i < array.length; i++) {
            let m = i;
            for (let j = i + 1; j < array.length; j++) {
                if (array[j] < array[m]) m = j;
                if (j % Math.ceil(array.length/50) === 0) await step([i, j], 0.1);
            }
            [array[i], array[m]] = [array[m], array[i]];
            await step([i, m]);
        }
    }

    async function cocktailSort() {
        let l = 0, r = array.length - 1;
        while (l < r) {
            for (let i = l; i < r; i++) { if (array[i] > array[i+1]) [array[i], array[i+1]] = [array[i+1], array[i]]; if (i%10===0) await step([i]); }
            r--;
            for (let i = r; i > l; i--) { if (array[i] < array[i-1]) [array[i], array[i-1]] = [array[i-1], array[i]]; if (i%10===0) await step([i]); }
            l++;
        }
    }

    async function gnomeSort() {
        let i = 0;
        while (i < array.length) {
            if (i === 0 || array[i] >= array[i-1]) i++;
            else { [array[i], array[i-1]] = [array[i-1], array[i]]; i--; if (i%10===0) await step([i]); }
        }
    }

    async function shellSort() {
        for (let gap = Math.floor(array.length/2); gap > 0; gap = Math.floor(gap/2)) {
            for (let i = gap; i < array.length; i++) {
                let temp = array[i], j = i;
                while (j >= gap && array[j-gap] > temp) { array[j] = array[j-gap]; j -= gap; await step([j], 0.1); }
                array[j] = temp;
            }
        }
    }

    async function stalinSort() {
        let max = array[0];
        for (let i = 1; i < array.length; i++) {
            if (array[i] < max) array[i] = 0; else max = array[i];
            await step([i], 0.5);
        }
    }

    async function abeSort() {
        let max = array[0];
        for (let i = 1; i < array.length; i++) {
            if (array[i] < max) array[i] = max; else max = array[i];
            await step([i], 0.5);
        }
    }

    async function sleepSort() {
        let copy = [...array], res = [];
        array.fill(0);
        copy.forEach(v => setTimeout(() => { if(!isSorting) return; res.push(v); array[res.length-1] = v; draw(); }, v * 50));
        while (res.length < copy.length) { await new Promise(r => setTimeout(r, 100)); if(!isSorting) return; }
    }

    async function bogoSort() {
        while (!array.every((v, i) => i === 0 || v >= array[i-1])) {
            for (let i = array.length-1; i > 0; i--) {
                const j = Math.floor(Math.random()*(i+1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            await step([], 2);
        }
    }

    async function miracleSort() {
        while (!array.every((v, i) => i === 0 || v >= array[i-1])) {
            await new Promise(r => setTimeout(r, 500));
            if (!isSorting) return;
        }
    }

    function updateInfo() {
        const a = document.getElementById('algoSelect').value;
        document.getElementById('logicText').innerText = info[a].logic;
        document.getElementById('complexityText').innerText = info[a].comp;
    }
</script>
</body>
</html>
